Полное ТЗ — разработка системы отчётов для Telegram-бота (с нуля, развёртывание на Replit)

Ниже — максимально подробное, «провести-и-сдать» ТЗ для агента/разработчика на Replit. ТЗ охватывает всё: архитектуру, DB, API/обработчики, cron, генерацию Excel, UI-поведения бота (сообщение + кнопка скачивания), тесты, логирование, безопасность, инструкции по развёртыванию и критериям приёмки.
Фокус — только на системе отчётов и Excel (всё остальное в боте не менять).

1. Коротко — цель и рамки

Цель: добавить/реализовать в существующем Telegram-боте модуль формирования отчётов, который:

собирает события подписки/отписки (использует существующие события бота),

хранит полную историю в одном Excel-файле subscribers_report.xlsx,

обновляет агрегированную статистику по пригласителям,

каждый день в заданное время создаёт новый лист (название — дата) с дневным отчётом,

ежедневно отправляет короткий текстовый отчёт в указанный чат и прикладывает кнопку «Скачать Excel-файл» (при нажатии — отправляет актуальный файл),

не меняет остальной функционал бота (создание ссылок, логика приглашений и т.п.).

Ограничения: Google Sheets и внешние хранилища — не используются. Всё — в одном локальном файле/файле на диске Replit.

2. Требования по среде и инструментам

Язык: Python 3.10+ (рекомендуется 3.11)

Telegram-клиент: aiogram v3.x или python-telegram-bot v20+ (указать в реализации; в ТЗ — aiogram предпочтительно, т.к. уже использовали ранее)

БД/хранение: SQLite (db.sqlite3) — для быстрой работы и восстановления. Excel = openpyxl + pandas для удобства генерации.

Планировщик: APScheduler (AsyncIOScheduler) или встроенные asyncio-таски.

Логирование: logging (ротация логов через logging.handlers.RotatingFileHandler)

Тесты: pytest + pytest-asyncio

Формат кода: PEP8, type hints, docstrings.

Развёртывание: Replit. Скрипт start.sh / run в Replit config. При использовании polling — токен безопасности (см. env vars).

Зависимости (requirements.txt):

aiogram==3.13.1
pandas==2.2.2
openpyxl==3.1.5
APScheduler==3.10.4
python-dotenv==1.0.1
pytz==2024.1
pytest
pytest-asyncio

3. Переменные окружения (обязательные)

Файл .env с этими ключами:

BOT_TOKEN=123456:ABC-DEF...        # token бота
ADMIN_IDS=111111111,222222222     # comma-separated list admin user_ids (получатели уведомлений)
TARGET_CHAT_ID=-1001234567890     # id канала/супергруппы (куда слать ежедневный отчёт)
REPORT_TIME=10:00                 # время ежедневного отчёта в формате HH:MM (UTC или TIMEZONE)
TIMEZONE=Asia/Almaty              # часовой пояс
DB_PATH=db.sqlite3
EXCEL_PATH=subscribers_report.xlsx
RETENTION_DAYS=3                  # число дней для проверки удержания

4. Структура проекта (файловая)
/bot_project
  ├─ bot.py                # точка запуска (запускает aiogram dispatcher, scheduler)
  ├─ handlers/
  │   ├─ events.py         # обработчики chat_member, message и т.д. (интеграция с существующими)
  │   └─ commands.py       # команды, обработчики кнопок (export, download)
  ├─ reports/
  │   ├─ report_manager.py # логика генерации/обновления Excel, создание листов по датам
  │   ├─ excel_templates.py# шаблоны/форматирование листов
  │   └─ scheduler.py      # задачи APScheduler для ежедневных отчётов
  ├─ db/
  │   ├─ db.py             # функции для работы с SQLite (CRUD)
  │   └─ migrations.sql    # DDL для инициализации
  ├─ utils/
  │   ├─ time_utils.py     # timezone helpers
  │   └─ logging_conf.py   # логирование и handlers
  ├─ tests/
  │   ├─ test_reports.py
  │   └─ test_db.py
  ├─ requirements.txt
  ├─ .env
  ├─ README.md
  └─ start.sh

5. DB: схема данных (SQLite)

Важно: предполагается, что события (вход/выход) отправляются в этот модуль из существующих обработчиков бота. Если такой возможность отсутствует, агент должен подключить слушатель chat_member и вызывать db.insert_event.

SQL (migrations.sql):

-- users table (если уже есть — использовать имеющуюся)
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tg_user_id INTEGER UNIQUE NOT NULL,
  username TEXT,
  name TEXT
);

-- inviters table (если уже есть — использовать)
CREATE TABLE IF NOT EXISTS inviters (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  invite_link TEXT
);

-- journal: все события (подписка/отписка/прочее)
CREATE TABLE IF NOT EXISTS journal (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  event_time TEXT NOT NULL,        -- ISO timestamp with TZ
  event_type TEXT NOT NULL,        -- 'subscribe' | 'unsubscribe' | 'join_request' | 'manual_add' ...
  tg_user_id INTEGER NOT NULL,     -- Telegram user id
  username TEXT,
  name TEXT,
  inviter_id INTEGER,              -- nullable
  status TEXT,                     -- 'subscribed'|'left' etc.
  note TEXT,                       -- e.g. 'repeat' if not first inviter
  FOREIGN KEY(inviter_id) REFERENCES inviters(id)
);

-- retention_checks table: stores retention evaluation results (so we don't re-evaluate same user)
CREATE TABLE IF NOT EXISTS retention_checks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  journal_id INTEGER NOT NULL,
  check_date TEXT NOT NULL,        -- date when check happened (ISO date)
  result TEXT NOT NULL,            -- 'retained'|'not_retained'|'pending'
  FOREIGN KEY(journal_id) REFERENCES journal(id)
);


Комментарий: journal — мастер-линия событий (лист 1 в Excel). retention_checks — хранит факт проверки удержания для каждой подписки, чтобы не пересчитывать.

6. Триггерные точки (интеграция с ботом)

При событии вступления (chat_member new member is member/administrator): вызвать db.insert_user_if_not_exists() и db.insert_journal_event(event_type='subscribe', ...).

Если invite_link присутствует — найти inviter_id по ссылке, иначе NULL.

Определить, первый ли это факт приглашения для данного tg_user_id — если не первый (есть запись в journal с другим inviter_id > 0), пометить note='repeat'.

При событии выхода: вставить journal запись event_type='unsubscribe' и обновить последнюю подписку для этого tg_user_id (поставить поле status='left' и дату выхода — реализуется либо отдельной записью, либо полем left_at — тут мы используем journal с отдельной записью типа unsubscribe).

Ручное добавление (админ через кнопку «Добавить пользователя вручную»): event_type='manual_add'.

Всё взаимодействие с DB должно быть идемпотентным и атомарным (использовать транзакции).

7. Логика ежедневной проверки удержания (scheduler)

Планировщик запускается при старте бота (APScheduler AsyncIOScheduler, timezone из .env).

Время запуска: REPORT_TIME (HH:MM) в TIMEZONE.

Что делает задача:

Собирает список подписок, у которых прошло >= RETENTION_DAYS дней с момента event_time и для которых ещё нет записи в retention_checks с check_date = today (чтобы не проверять повторно).

Конкретно: на текущую дату D бот находит события subscribe с event_time ≤ D - RETENTION_DAYS (по датам).

Для каждого найденного journal-записа:

Проверяет в journal есть ли последующее событие unsubscribe между event_time и now; если есть — result='not_retained', иначе result='retained'.

Вставляет запись в retention_checks.

Обновляет агрегированную статистику (пересчитывает лист Статистика / таблицу).

Формирует дневной отчёт (в памяти) и вызывает генерацию нового листа Excel (если лист за текущую дату уже не создан).

Отправляет короткий текстовый отчёт в TARGET_CHAT_ID и предлагает кнопку «📤 Скачать Excel-файл».

Idempotency: если задача была выполнена ранее за этот день (лист уже создан или retention_checks уже имеются), повторный запуск не должен дублировать данные.

8. Генерация Excel (report_manager.py)

Функции:

ensure_excel_exists(path) — создает файл, если отсутствует, с пустыми листами История и Статистика.

append_journal_to_history_excel(journal_rows) — добавляет или обновляет строки в листе История. Нужно хранить уникальный идентификатор (journal.id) в скрытой колонке чтобы при апдейтах обновлять существующие строки.

recalculate_statistics() — пересчитывает лист Статистика из DB (агрегация).

create_daily_report_sheet(date, report_payload) — добавляет лист ДД-ММ-ГГГГ с таблицей параметров (Параметр | Значение) и дополнительной таблицей Топ-N пригласителей.

export_excel_copy() — передаёт путь к актуальному subscribers_report.xlsx (или создаёт временную копию если нужно), чтобы бот мог отправить файл.

Формат листа История:
Колонки:

JournalID | Дата/время | Действие | User ID | Username | Name | Пригласивший | Статус | Примечание


JournalID — скрытая колонка с id из DB (для синхронизации).

Формат листа Статистика:

Пригласивший | Всего приглашено | Подписаны сейчас | Отписались | % удержания


Формат дневного листа (пример 12-09-2025):

БлокA: сводка Параметр/Значение (как в заданном шаблоне).

БлокB: таблица Топ-N пригласителей: Пригласивший | Новые подписки | Удержано(3д) | Вышли в тот же день | % удержания.

Стиль: заголовки жирные, ширина колонок оптимизирована, даты в ISO или DD.MM.YYYY HH:MM.

9. Отправка короткого телеграм-отчёта

Формируется текст (пример из ТЗ).

Сообщение отправляется в TARGET_CHAT_ID (из .env).

Под сообщением — InlineKeyboard с одной кнопкой:

Текст: 📤 Скачать Excel-файл

Callback или URL: при нажатии бот присылает файл subscribers_report.xlsx в чат (через bot.send_document).

Поведение кнопки: если файл большой, создавать временную копию и отправлять; затем удалять временную файл.

10. API/команды (для админов)

/export — ручная генерация Excel (с обновлением История, Статистика и созданием листа за сегодня) и отправка файла админу, который вызвал команду.

Inline-кнопка «📤 Скачать Excel-файл» — отправка файла.

/set_report_time HH:MM — изменение времени ежедневного отчёта (обновление scheduler).

/force_retention_check — ручной запуск проверки удержания (для отладки). Доступно только ADMIN_IDS.

/get_report status — возвращает путь/файл отчёта за запрошенную дату (optional).

Все команды должны проверять, что вызывающий — админ (is_admin).

11. Тесты и кейсы

Unit tests

DB inserts: добавление subscribe/unsubscribe событий, проверки, что journal хранит корректные данные.

Retention logic: для ряда событий (вход+выход на 1/2/3+ дней) проверить, что результат = retained/not_retained.

Excel generation: создать тестовый DB, вызвать create_daily_report_sheet и проверить, что лист создан и ключевые ячейки содержат ожидаемые значения.

Idempotency: повторный запуск генерации того же дня не создаёт дубликатов.

Integration tests

Эмуляция событий бота: серия subscribe/unsubscribe в DB, запуск scheduler job, проверка Excel и содержимого.

Проверка отправки файла — можно мокать bot.send_document.

Acceptance tests (ручные)

Запустить на dev окружении.

Создать 10 подписок в день D-3, 2 из них отписались в тот же день → в утреннем отчёте D результат: Новые=10, Остались на D: число 8 (80%), Вышли в тот же день:2.

Нажать кнопку «Скачать Excel-файл» — файл приходит и содержит листы История, Статистика, DD-MM-YYYY.

12. Логирование, мониторинг, ошибки

Логи: INFO/ERROR хранить в logs/ (rotating).

При ошибках генерации/IO отправлять уведомление админу (telegram message).

Обработать исключения: файл занят (IOError) → попытка повторной записи спустя N сек / отправка уведомления и создание временной копии.

При нехватке места на Replit — логировать и оповещать.

13. Безопасность и права

Токен бота — хранить в .env, не коммитить в репозиторий.

Ограничить команды /export, /force_retention_check, /set_report_time только ADMIN_IDS.

Если бот будет отправлять файл — убедиться, что не публикуются личные данные ненужным людям (отправка только в TARGET_CHAT_ID либо в личку админа).

Не хранить Excel с публичным доступом.

14. Развёртывание на Replit — инструкция

Создать новый Repl (Python).

Залить структуру проекта.

В Settings → Secrets (Environment variables) добавить BOT_TOKEN, ADMIN_IDS, TARGET_CHAT_ID, REPORT_TIME, TIMEZONE, DB_PATH, EXCEL_PATH, RETENTION_DAYS.

Настроить start.sh:

#!/bin/bash
pip install -r requirements.txt
python bot.py


В Replit UI — запустить. Рекомендуется Polling (aiogram.start_polling). Если нужно Webhook — настроить внешний keepalive.

Замечание: Replit может перезапускать контейнер — убедитесь, что DB и Excel находятся в persistent storage Replit (рабочая директория) и при рестарте сохраняются. Для бэкапа можно дополнительно выгружать файл в репозиторий/драйв, но это optional.

15. Документация и deliverables

Обязательные поставки:

Полный исходный код в репозитории Replit (или GitHub).

README.md с инструкциями: установка, переменные окружения, запуск, тесты, примеры команд.

migrations.sql и script инициализации DB (если нужно).

Пример .env.example.

Unit и integration тесты в папке tests/.

Демонстрация: скриншот или видео запуска ежедневного отчёта + присылка Excel-файла.

16. Acceptance criteria — критерии приёмки (каждый выполняется)

По событию subscribe/unsubscribe добавляются строки в таблицу journal в DB (проверка через sqlite client).

Каждое утро (или в заданное время) создаётся новый лист в subscribers_report.xlsx с корректной датой и корректной сводкой.

В файле есть лист История с полями JournalID, Дата/время, Действие, User ID, Username, Name, Пригласивший, Статус, Примечание.

В файле есть лист Статистика с корректными вычислениями для всех пригласителей (включая % удержания).

Кнопка 📤 Скачать Excel-файл в сообщении присылает актуальный файл.

Поведение идемпотентное: повторный запуск задания того же дня не дублирует листы и не дублирует retention_checks.

Все команды, отправленные не-админом, не выполняются (403-like behaviour).

Unit tests: все новые тесты проходят (pytest) в CI.

17. Примерные вспомогательные куски кода (псевдо/мини-реализация)

Для ускорения разработки: включить методы в report_manager.py:

generate_daily_report_payload(date) -> dict — возвращает словарь со всеми значениями (new_count, retained_count, left_same_day_count, top3 list, dynamics).

update_excel_with_payload(payload) — создает лист и обновляет основные листы.

send_short_report(payload) — формирует текст и отправляет via bot.send_message.

18. План работ (шаги для агента)

Проанализировать текущую кодовую базу бота (не менять остальное).

Добавить/проверить DB-таблицы и миграции.

Имплементировать функции вставки событий в journal (если уже есть — использовать их).

Реализовать report_manager (Excel) + тесты.

Реализовать scheduler и ежедневную задачу retention.

Подключить отправку короткого сообщения и кнопку скачивания.

Написать unit/integration тесты.

Тестирование на dev Replit (эмуляция событий).

Финальная проверка по acceptance criteria.

Документация + handover.